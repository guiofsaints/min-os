# NextUI Windows Tooling Report

This document describes the expected outputs from the Windows analysis tooling, how to interpret them, and how they should be consumed by other assessment prompts.

---

## Overview

After running `.\tools\windows\run-analysis.ps1`, you will have a comprehensive set of reports in `.guided/assessment/reports/`. This document explains each report, its format, key metrics, and how to use it.

---

## Report Index

### Generated Files

```
.guided/assessment/reports/
â”œâ”€â”€ analysis-summary.md           # ğŸ“Š High-level overview (read this first)
â”œâ”€â”€ code-metrics.json             # ğŸ“ˆ LOC, complexity, language breakdown
â”œâ”€â”€ code-metrics.txt              # ğŸ“ˆ Human-readable metrics
â”œâ”€â”€ duplication/                  # ğŸ”„ Code duplication analysis
â”‚   â”œâ”€â”€ index.html                # Interactive duplication dashboard
â”‚   â”œâ”€â”€ jscpd-report.json         # Machine-readable duplication data
â”‚   â””â”€â”€ ...
â”œâ”€â”€ cppcheck.txt                  # ğŸ› Static analysis warnings
â”œâ”€â”€ cppcheck-full.txt             # ğŸ› Detailed static analysis (all checks)
â”œâ”€â”€ cppcheck.xml                  # ğŸ› XML format for parsing
â”œâ”€â”€ clang-tidy.txt                # ğŸ” Linting suggestions
â”œâ”€â”€ patterns-todos.txt            # ğŸ“ TODO/FIXME/HACK comments
â”œâ”€â”€ patterns-malloc.txt           # âš ï¸  malloc without null checks
â”œâ”€â”€ patterns-magic-numbers.txt    # ğŸ”¢ Hex constants
â”œâ”€â”€ patterns-unsafe-funcs.txt     # ğŸš¨ strcpy, sprintf, gets usage
â”œâ”€â”€ patterns-commented-code.txt   # ğŸ’¬ Commented-out code blocks
â”œâ”€â”€ files-c.txt                   # ğŸ“ List of all C files
â”œâ”€â”€ complexity-per-module.csv     # ğŸ“Š Complexity by module
â””â”€â”€ build-logs/                   # ğŸ—ï¸  Build verification (if Docker available)
    â”œâ”€â”€ build.log                 # Full build output
    â””â”€â”€ compiler-commands.txt     # Extracted compiler invocations
```

---

## Report Details

### 1. analysis-summary.md

**Purpose**: Executive summary of all analysis findings.

**Generated By**: `run-analysis.ps1` (aggregates all tool outputs)

**Format**: Markdown

**Key Sections**:
- **Codebase Size**: Total LOC, language breakdown, file counts
- **Top Issues**: Most critical findings from static analyzers
- **Duplication Summary**: % of duplicated code, largest clones
- **Complexity Hotspots**: Files with highest cyclomatic complexity
- **Technical Debt**: TODO count, unsafe patterns, missing null checks
- **Recommendations**: Top 3-5 actionable items

**How to Read**:
1. Start here for a 5-minute overview
2. Identify high-priority issues (severity: High, Medium, Low)
3. Use as a table of contents to drill into specific reports

**Example Content**:
```markdown
## Analysis Summary - NextUI (2025-11-15)

### Codebase Metrics
- **Total Lines**: 139,847 (59% in unmaintained platforms)
- **Active Code**: 57,348 LOC (C: 98%, Shell: 1%, Make: 1%)
- **Average Complexity**: 12.3 per function
- **Files Analyzed**: 312 C files, 89 headers

### Top Findings
1. **HIGH**: 47 malloc calls without null checks â†’ Crash risk
2. **MEDIUM**: 23% code duplication (32,198 duplicated lines)
3. **MEDIUM**: 127 TODO/FIXME comments â†’ Incomplete features
4. **LOW**: 12 unsafe string functions (strcpy, sprintf)

### Complexity Hotspots
- minarch.c: 7186 lines, avg complexity 18.7
- nextui.c: 3221 lines, main() is 1120 lines
- api.c: 4219 lines, mixed responsibilities

### Recommendations
1. Archive `workspace/_unmaintained/` â†’ Reduces LOC by 60%
2. Add null checks to malloc/fopen â†’ Improves stability
3. Refactor god functions â†’ Improves maintainability
```

**Consumed By**:
- Human reviewers for quick assessment
- `assessment.nextui.codebase-deep-dive` for context
- Refactor planning prompts for prioritization

---

### 2. code-metrics.json

**Purpose**: Quantitative metrics for programmatic analysis.

**Generated By**: `scc --format json`

**Format**: JSON

**Key Fields**:
```json
{
  "Languages": [
    {
      "Name": "C",
      "Bytes": 2847392,
      "CodeBytes": 1987234,
      "Lines": 98745,
      "Code": 67890,
      "Comment": 12345,
      "Blank": 18510,
      "Complexity": 8234,
      "Count": 312,  // file count
      "WeightedComplexity": 0.12,
      "Files": [...]
    }
  ],
  "Total": {...}
}
```

**How to Read**:
- **Code**: Actual lines of code (excluding comments/blanks)
- **Complexity**: Sum of cyclomatic complexity for all functions
- **WeightedComplexity**: Complexity / Lines of Code
- **Count**: Number of files

**Key Metrics to Extract**:
1. Total LOC by language
2. Code-to-comment ratio (`Comment / Code`)
3. Average complexity (`Complexity / Count`)
4. Largest files (sort `Files` by `Code`)

**Consumed By**:
- Scripts for generating charts/graphs
- Automated refactor tooling
- Regression tracking (compare metrics over time)

**Example Usage** (PowerShell):
```powershell
$metrics = Get-Content .guided/assessment/reports/code-metrics.json | ConvertFrom-Json
$cLang = $metrics.Languages | Where-Object { $_.Name -eq "C" }
Write-Host "Total C LOC: $($cLang.Code)"
Write-Host "Average Complexity: $($cLang.Complexity / $cLang.Count)"
```

---

### 3. duplication/index.html

**Purpose**: Visual, interactive duplication analysis.

**Generated By**: `jscpd --reporters html`

**Format**: HTML dashboard (open in browser)

**Key Sections**:
- **Overview**: Total duplications, % of codebase affected
- **Clones Table**: List of duplicated blocks with locations
- **File Heatmap**: Visual representation of duplication density
- **Duplication Chart**: Trend over directories

**How to Read**:
1. **Open**: Double-click `index.html` or `Start-Process duplication/index.html`
2. **Overview**: Check duplication % (aim for <10%)
3. **Clones**: Click on entries to see side-by-side diff
4. **Heatmap**: Red = high duplication, green = low

**Key Metrics**:
- **Total Clones**: Number of duplicated blocks
- **Lines Duplicated**: Total lines affected
- **Tokens Duplicated**: More accurate than lines (ignores whitespace)
- **% Duplicated**: `Lines Duplicated / Total Lines * 100`

**What to Look For**:
- Large clones (>50 lines) â†’ High-priority refactoring targets
- Cross-platform duplication â†’ Extract to shared library
- Copy-pasted bug fixes â†’ Indicates missing abstraction

**Example Findings**:
```
Clone #1: workspace/all/minarch/minarch.c:1234-1287 (53 lines)
        vs workspace/_unmaintained/miyoomini/minarch/minarch.c:1234-1287
â†’ Recommendation: Merge into shared module

Clone #2: workspace/all/nextui/nextui.c:456-478 (22 lines)
        vs workspace/all/nextui/nextui.c:890-912
â†’ Recommendation: Extract to function
```

**Consumed By**:
- Refactor planning (identify consolidation opportunities)
- Code review (highlight risky patterns)
- Technical debt tracking

---

### 4. cppcheck.txt

**Purpose**: Static analysis warnings for C/C++ code.

**Generated By**: `cppcheck --enable=all`

**Format**: Plain text (one warning per line)

**Entry Format**:
```
[file:line]: (severity) message
```

**Example**:
```
workspace/all/minarch/minarch.c:1234: [error] Memory leak: ptr
workspace/all/nextui/nextui.c:567: [warning] Possible null pointer dereference
workspace/all/common/api.c:890: [style] Variable 'x' is assigned a value that is never used
```

**Severity Levels**:
1. **error**: Critical bugs (memory leaks, null deref, buffer overflow)
2. **warning**: Likely bugs (uninitialized variables, logic errors)
3. **style**: Code quality (unused variables, redundant code)
4. **performance**: Inefficiencies (slow algorithms, unnecessary copies)
5. **portability**: Platform-specific issues (endianness, size assumptions)
6. **information**: Low-priority suggestions

**How to Read**:
1. Sort by severity: `Select-String "\[error\]" cppcheck.txt`
2. Group by file: `Select-String "minarch.c" cppcheck.txt`
3. Count by severity: `(Select-String "\[error\]" cppcheck.txt).Count`

**Prioritization**:
- **Fix immediately**: `[error]` - memory leaks, null deref
- **Fix soon**: `[warning]` - uninitialized vars, logic errors
- **Nice to have**: `[style]` - code quality improvements

**Common False Positives**:
- "Unmatched suppression" (can ignore)
- "Include file not found" (cross-compilation, can suppress with `--suppress=missingIncludeSystem`)

**Consumed By**:
- Refactor plan (prioritize safety fixes)
- Code review (verify fixes)
- CI/CD (fail build on `[error]`)

---

### 5. clang-tidy.txt

**Purpose**: LLVM-based linting and modernization suggestions.

**Generated By**: `clang-tidy`

**Format**: Plain text with fix hints

**Entry Format**:
```
file:line:col: warning: message [check-name]
  suggestion (fix available)
```

**Example**:
```
workspace/all/minarch/minarch.c:1234:5: warning: Value stored to 'ptr' is never read [clang-analyzer-deadcode.DeadStores]
  ptr = malloc(size);
  ^     ~~~~~~~~~~~~

workspace/all/nextui/nextui.c:567:10: warning: Use of memory after it is freed [clang-analyzer-unix.Malloc]
  return ptr->data;
         ^
```

**Check Categories** (as configured in `.clang-tidy`):
- `bugprone-*`: Likely bugs
- `clang-analyzer-*`: Deep static analysis
- `performance-*`: Inefficiencies
- `readability-*`: Code clarity
- `modernize-*`: C99/C11 upgrades (less relevant for embedded C)

**How to Read**:
1. Focus on `bugprone-` and `clang-analyzer-` first
2. Look for "fix available" â†’ Auto-fixable with `clang-tidy -fix`
3. Group by check type: `Select-String "\[bugprone-" clang-tidy.txt`

**Advantages over cppcheck**:
- More sophisticated analysis (LLVM compiler infrastructure)
- Can auto-fix issues (`clang-tidy -fix`)
- Better C++ support (though NextUI is C)

**Limitations**:
- Requires compilation database (`compile_commands.json`)
- Slower than cppcheck
- More opinionated (some checks may not fit NextUI's style)

**Consumed By**:
- Automated refactoring (use `-fix` mode)
- Code quality gate (CI/CD)
- Developer education (learn from warnings)

---

### 6. patterns-*.txt

**Purpose**: Search results for specific code patterns.

**Generated By**: `ripgrep` (rg)

**Files**:
- `patterns-todos.txt`: TODO, FIXME, HACK, XXX comments
- `patterns-malloc.txt`: malloc without null checks (heuristic)
- `patterns-magic-numbers.txt`: Hex constants (e.g., `0xDEADBEEF`)
- `patterns-unsafe-funcs.txt`: strcpy, sprintf, gets usage
- `patterns-commented-code.txt`: Commented-out code blocks

**Format**: `file:line:content`

**Example (`patterns-todos.txt`)**:
```
workspace/all/minarch/minarch.c:1234:// TODO: Add error handling here
workspace/all/nextui/nextui.c:567:// FIXME: Memory leak in this path
workspace/all/common/api.c:890:// HACK: Temporary workaround for SDL bug
```

**How to Read**:
1. Count total: `(Get-Content patterns-todos.txt).Count`
2. Group by type: `Select-String "TODO" patterns-todos.txt`
3. Group by file: `Select-String "minarch.c" patterns-todos.txt`

**Actionable Insights**:
- **TODOs**: Incomplete features, deferred work
- **FIXMEs**: Known bugs or issues
- **HACKs**: Temporary solutions that need proper fix
- **malloc patterns**: Add null checks
- **Magic numbers**: Define constants with meaningful names
- **Unsafe functions**: Replace with safe alternatives (strncpy, snprintf, fgets)

**Consumed By**:
- GitHub issue creation (convert TODOs to issues)
- Refactor plan (prioritize by frequency)
- Security audit (focus on unsafe functions)

---

### 7. files-c.txt

**Purpose**: Complete list of C source files.

**Generated By**: `fd -e c -e h`

**Format**: One file path per line

**Example**:
```
workspace/all/minarch/minarch.c
workspace/all/minarch/libretro.h
workspace/all/nextui/nextui.c
...
```

**How to Read**:
- Total file count: `(Get-Content files-c.txt).Count`
- Find largest: `fd -e c -e h | ForEach-Object { [PSCustomObject]@{File=$_; Lines=(Get-Content $_ | Measure-Object -Line).Lines} } | Sort-Object -Descending Lines`

**Consumed By**:
- Automated tool input (e.g., run clang-tidy on all files)
- Build system verification
- File change tracking

---

### 8. complexity-per-module.csv

**Purpose**: Complexity metrics per module/directory.

**Generated By**: `run-analysis.ps1` (aggregates scc output)

**Format**: CSV

**Columns**:
```csv
Module,Files,LOC,Complexity,AvgComplexity
minarch,15,7186,287,19.1
nextui,8,3221,156,19.5
api,12,4219,203,16.9
```

**How to Read**:
1. Sort by AvgComplexity (descending) â†’ Identify complex modules
2. Sort by LOC (descending) â†’ Identify large modules
3. Plot LOC vs. Complexity â†’ Find outliers

**Use Cases**:
- Identify refactoring priorities (high complexity modules)
- Track complexity over time (regression testing)
- Compare modules for consistency

**Consumed By**:
- Automated dashboards
- Refactor planning
- Technical debt visualization

---

## Interpretation Guide

### Red Flags ğŸš©

| Metric | Threshold | Implication |
|--------|-----------|-------------|
| **Duplication %** | >15% | High refactoring burden |
| **Avg Complexity** | >15 | Hard to maintain, test |
| **Largest Function** | >200 lines | God function, split needed |
| **TODO Count** | >50 | Significant incomplete work |
| **`[error]` Count** | >10 | Critical bugs present |
| **malloc w/o null check** | >20 | Crash risk |
| **unsafe funcs** | >5 | Security/buffer overflow risk |

### Green Flags âœ…

| Metric | Threshold | Implication |
|--------|-----------|-------------|
| **Duplication %** | <10% | Good code reuse |
| **Avg Complexity** | <10 | Maintainable |
| **Comment Ratio** | >10% | Well-documented |
| **`[error]` Count** | 0 | No critical bugs |
| **TODO Count** | <20 | Work is complete |

---

## How to Consume Reports in Other Prompts

### For `assessment.nextui.codebase-deep-dive`

**Read**:
1. `analysis-summary.md` for high-level context
2. `code-metrics.json` for quantitative data
3. `duplication/jscpd-report.json` for duplication details
4. `cppcheck.txt` for bug counts by severity

**Extract**:
```powershell
# Example: Extract top 10 most complex files
$metrics = Get-Content .guided/assessment/reports/code-metrics.json | ConvertFrom-Json
$cFiles = $metrics.Languages | Where-Object { $_.Name -eq "C" } | Select-Object -ExpandProperty Files
$cFiles | Sort-Object -Property Complexity -Descending | Select-Object -First 10 | Format-Table Name, Lines, Code, Complexity
```

### For Refactor Planning

**Prioritize**:
1. **P0**: Fix `[error]` findings from cppcheck
2. **P1**: Add null checks to malloc calls (patterns-malloc.txt)
3. **P2**: Refactor duplicated code (duplication report)
4. **P3**: Split god functions (complexity metrics)

### For Security Audit

**Focus**:
1. `patterns-unsafe-funcs.txt` â†’ Buffer overflow risks
2. `cppcheck.txt` â†’ Filter for `[security]` or `buffer` keywords
3. `patterns-malloc.txt` â†’ Memory management issues

---

## Report Maintenance

### Archiving Old Reports

```powershell
# run-analysis.ps1 automatically archives previous runs
.guided/assessment/reports/archive/
â”œâ”€â”€ 2025-11-15-143022/
â”‚   â”œâ”€â”€ code-metrics.json
â”‚   â”œâ”€â”€ cppcheck.txt
â”‚   â””â”€â”€ ...
â””â”€â”€ 2025-11-14-091545/
    â””â”€â”€ ...
```

### Comparing Reports Over Time

```powershell
# Compare duplication %
$old = Get-Content .guided/assessment/reports/archive/2025-11-14*/duplication/jscpd-report.json | ConvertFrom-Json
$new = Get-Content .guided/assessment/reports/duplication/jscpd-report.json | ConvertFrom-Json
Write-Host "Old: $($old.statistics.total.percentage)% duplicated"
Write-Host "New: $($new.statistics.total.percentage)% duplicated"
```

---

## Visualization Recommendations

### Tools for Report Visualization

1. **Excel/LibreOffice Calc**: Import CSVs for charts
2. **Power BI**: Dashboard for metrics tracking
3. **Grafana**: Time-series complexity tracking
4. **Matplotlib (Python)**: Custom charts from JSON

### Example: Duplication Trend Chart

```python
import json
import matplotlib.pyplot as plt

# Load jscpd report
with open('.guided/assessment/reports/duplication/jscpd-report.json') as f:
    data = json.load(f)

# Extract data
clones = data['duplicates']
sizes = [c['lines'] for c in clones]

# Plot
plt.hist(sizes, bins=20)
plt.xlabel('Clone Size (lines)')
plt.ylabel('Frequency')
plt.title('Distribution of Code Clone Sizes')
plt.savefig('.guided/assessment/reports/duplication-chart.png')
```

---

## Limitations and Caveats

### What Reports Don't Show

- **Runtime behavior**: No profiling, no memory usage, no performance metrics
- **Test coverage**: NextUI has no automated tests yet
- **API usage**: No call graph without Doxygen
- **Security vulnerabilities**: Static analysis has false negatives
- **Code quality**: Subjective aspects (readability, naming, architecture)

### False Positives

- **cppcheck**: Can flag intentional patterns (e.g., error codes as unused)
- **jscpd**: May flag legitimate duplication (e.g., platform-specific code)
- **ripgrep patterns**: Heuristics may miss context (e.g., null checks in different scope)

**Mitigation**: Always manually review findings before acting.

---

## Next Steps

1. **Read** `analysis-summary.md` for 5-minute overview
2. **Open** `duplication/index.html` in browser for visual exploration
3. **Filter** `cppcheck.txt` for `[error]` severity
4. **Count** TODOs and create GitHub issues
5. **Feed** JSON reports into deep-dive assessment
6. **Track** metrics over time (run analysis weekly)

---

## References

- [scc Output Format](https://github.com/boyter/scc#output-formats)
- [jscpd Report Format](https://github.com/kucherenko/jscpd/tree/master/packages/jscpd#reporters)
- [Cppcheck Manual](https://cppcheck.sourceforge.io/manual.pdf)
- [clang-tidy Checks List](https://clang.llvm.org/extra/clang-tidy/checks/list.html)
